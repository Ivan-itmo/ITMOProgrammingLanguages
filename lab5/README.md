# Практическое занятие №5: Асинхронное программирование в C#

Изучение модели `async/await` и эффективной обработки I/O-операций в .NET.

## Цель
Преобразовать синхронный блокирующий код в асинхронный и продемонстрировать **существенный выигрыш в производительности** при параллельном выполнении независимых сетевых запросов.

---

## Этапы работы

### 1. Синхронная модель (блокирующая)
- Использование `HttpClient.GetStringAsync(...).Result`
- Последовательное выполнение трёх HTTP-запросов
- **Проблема**: основной поток блокируется на всё время ожидания → низкая производительность, «зависания» в UI

### 2. Асинхронная модель (последовательная)
- Замена `.Result` на `await`
- Сигнатура `Main`: `static async Task Main(string[] args)`
- Поток **не блокируется** во время ожидания → приложение остаётся отзывчивым

### 3. Параллельное выполнение с `Task.WhenAll`
- Все запросы запускаются **одновременно**
- Результаты ожидаются через `await Task.WhenAll(task1, task2, task3)`
- **Результат**: общее время ≈ длительности самого медленного запроса (ускорение в 2–3 раза)

### 4. Дополнительное задание: потоковая обработка (`IAsyncEnumerable<T>`)
- Использование `Task.WhenAny` в цикле
- Результаты обрабатываются **по мере поступления**
- Полезно, когда важна **быстрая реакция на первый результат**, а не общая скорость агрегации

---

## Используемые технологии
- `HttpClient` — выполнение HTTP-запросов
- `System.Diagnostics.Stopwatch` — замер производительности
- `async` / `await` — основа асинхронной модели
- `Task.WhenAll` / `Task.WhenAny` — управление группами задач
- `IAsyncEnumerable<T>` — асинхронные потоки данных